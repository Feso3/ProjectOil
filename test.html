<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Engine Tests</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f7fa;
    }

    h1 {
      color: #1d2433;
      border-bottom: 3px solid #2f5fe8;
      padding-bottom: 10px;
    }

    .test-section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .test-section h2 {
      color: #2f5fe8;
      margin-top: 0;
    }

    .test-case {
      padding: 12px;
      margin: 8px 0;
      border-left: 4px solid #ddd;
      background: #f9fafb;
      border-radius: 4px;
    }

    .test-case.pass {
      border-left-color: #20b26b;
      background: #f0fdf4;
    }

    .test-case.fail {
      border-left-color: #e84a5f;
      background: #fef2f2;
    }

    .test-name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .test-result {
      font-size: 0.9em;
      color: #666;
    }

    .summary {
      background: #2f5fe8;
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      text-align: center;
    }

    .summary.all-pass {
      background: #20b26b;
    }

    .summary.has-fail {
      background: #e84a5f;
    }

    .summary h2 {
      margin: 0 0 10px 0;
    }

    .summary .stats {
      font-size: 1.2em;
    }

    .board-viz {
      display: inline-grid;
      grid-template-columns: repeat(8, 24px);
      grid-template-rows: repeat(8, 24px);
      gap: 2px;
      margin: 10px 0;
      font-size: 10px;
      font-weight: bold;
    }

    .board-viz .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #ddd;
      background: #fff;
    }

    .board-viz .cell.winning {
      background: #ffd700;
      border-color: #20b26b;
    }

    .board-viz .cell.x {
      color: #1b6ef3;
    }

    .board-viz .cell.o {
      color: #e84a5f;
    }

    .error-message {
      color: #e84a5f;
      font-family: monospace;
      font-size: 0.85em;
      margin-top: 4px;
      padding: 8px;
      background: #fef2f2;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>Checkerboard Tic-Tac-Toe - Game Engine Tests</h1>
  <div id="test-results"></div>

  <script src="game-engine.js"></script>
  <script src="cpu-player.js"></script>
  <script>
    // Test runner
    class TestRunner {
      constructor() {
        this.tests = [];
        this.passed = 0;
        this.failed = 0;
      }

      test(name, fn) {
        this.tests.push({ name, fn });
      }

      async run() {
        const resultsContainer = document.getElementById('test-results');

        for (const { name, fn } of this.tests) {
          try {
            await fn();
            this.passed++;
            this.renderTestCase(resultsContainer, name, true);
          } catch (error) {
            this.failed++;
            this.renderTestCase(resultsContainer, name, false, error.message);
          }
        }

        this.renderSummary(resultsContainer);
      }

      renderTestCase(container, name, passed, errorMessage = null) {
        const section = container.querySelector('.current-section') || container;
        const testCase = document.createElement('div');
        testCase.className = `test-case ${passed ? 'pass' : 'fail'}`;

        const testName = document.createElement('div');
        testName.className = 'test-name';
        testName.textContent = `${passed ? '✓' : '✗'} ${name}`;
        testCase.appendChild(testName);

        if (!passed && errorMessage) {
          const error = document.createElement('div');
          error.className = 'error-message';
          error.textContent = errorMessage;
          testCase.appendChild(error);
        }

        section.appendChild(testCase);
      }

      section(name) {
        const resultsContainer = document.getElementById('test-results');
        const section = document.createElement('div');
        section.className = 'test-section current-section';

        const heading = document.createElement('h2');
        heading.textContent = name;
        section.appendChild(heading);

        resultsContainer.appendChild(section);
      }

      renderSummary(container) {
        const summary = document.createElement('div');
        const total = this.passed + this.failed;
        const allPass = this.failed === 0;

        summary.className = `summary ${allPass ? 'all-pass' : 'has-fail'}`;
        summary.innerHTML = `
          <h2>${allPass ? '✓ All Tests Passed!' : '✗ Some Tests Failed'}</h2>
          <div class="stats">
            <strong>${this.passed}</strong> passed,
            <strong>${this.failed}</strong> failed,
            <strong>${total}</strong> total
          </div>
        `;

        container.insertBefore(summary, container.firstChild);
      }

      visualizeBoard(game, title = '') {
        const viz = document.createElement('div');
        viz.style.marginTop = '10px';

        if (title) {
          const titleEl = document.createElement('div');
          titleEl.textContent = title;
          titleEl.style.fontWeight = 'bold';
          titleEl.style.marginBottom = '5px';
          viz.appendChild(titleEl);
        }

        const boardViz = document.createElement('div');
        boardViz.className = 'board-viz';

        const winningIndices = new Set(game.winningLine || []);

        for (let i = 0; i < game.CELLS_COUNT; i++) {
          const cell = document.createElement('div');
          cell.className = 'cell';

          if (game.board[i] === game.PLAYER_X) {
            cell.textContent = 'X';
            cell.classList.add('x');
          } else if (game.board[i] === game.PLAYER_O) {
            cell.textContent = 'O';
            cell.classList.add('o');
          }

          if (winningIndices.has(i)) {
            cell.classList.add('winning');
          }

          boardViz.appendChild(cell);
        }

        viz.appendChild(boardViz);
        return viz;
      }
    }

    // Assertion helpers
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }

    function assertEquals(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, got ${actual}`);
      }
    }

    function assertArrayEquals(actual, expected, message) {
      if (JSON.stringify(actual) !== JSON.stringify(expected)) {
        throw new Error(message || `Expected [${expected}], got [${actual}]`);
      }
    }

    // Test suite
    const runner = new TestRunner();

    // Basic functionality tests
    runner.section('Basic Functionality');

    runner.test('Game initializes with empty 8x8 board', () => {
      const game = new GameEngine();
      assertEquals(game.board.length, 64, 'Board should have 64 cells');
      assertEquals(game.currentPlayer, 'X', 'X should start first');
      assertEquals(game.gameOver, false, 'Game should not be over initially');
    });

    runner.test('Valid moves can be applied', () => {
      const game = new GameEngine();
      const result = game.applyMove(0);
      assert(result.success, 'Move should succeed');
      assertEquals(game.board[0], 'X', 'Cell should contain X');
      assertEquals(game.currentPlayer, 'O', 'Turn should switch to O');
    });

    runner.test('Invalid moves are rejected', () => {
      const game = new GameEngine();
      game.applyMove(0);
      const result = game.applyMove(0); // Same cell
      assertEquals(result.success, false, 'Move should fail');
    });

    runner.test('Moves out of bounds are rejected', () => {
      const game = new GameEngine();
      const result1 = game.applyMove(-1);
      const result2 = game.applyMove(64);
      assertEquals(result1.success, false, 'Negative index should fail');
      assertEquals(result2.success, false, 'Index >= 64 should fail');
    });

    // Horizontal win tests
    runner.section('Horizontal Win Detection');

    runner.test('Horizontal win in opponent side (X in top half) - VALID', () => {
      const game = new GameEngine();
      // X wins in row 0 (top half, X's opponent side)
      // X: 0,1,2,3  O: 32,33,34
      game.applyMove(0);  // X
      game.applyMove(32); // O
      game.applyMove(1);  // X
      game.applyMove(33); // O
      game.applyMove(2);  // X
      game.applyMove(34); // O
      const result = game.applyMove(3);  // X wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'X', 'X should win');
      assertArrayEquals(result.winningLine, [0, 1, 2, 3], 'Winning line should be [0,1,2,3]');
    });

    runner.test('Horizontal win in opponent side (O in bottom half) - VALID', () => {
      const game = new GameEngine();
      // O wins in row 7 (bottom half, O's opponent side)
      // Indices: 56,57,58,59
      game.applyMove(0);  // X
      game.applyMove(56); // O
      game.applyMove(1);  // X
      game.applyMove(57); // O
      game.applyMove(2);  // X
      game.applyMove(58); // O
      game.applyMove(8);  // X
      const result = game.applyMove(59); // O wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'O', 'O should win');
      assertArrayEquals(result.winningLine, [56, 57, 58, 59], 'Winning line should be [56,57,58,59]');
    });

    runner.test('Horizontal win in home side (X in bottom half) - INVALID', () => {
      const game = new GameEngine();
      // X attempts to win in row 7 (bottom half, X's home side) - should NOT count
      // Indices: 56,57,58,59
      game.applyMove(56); // X
      game.applyMove(0);  // O
      game.applyMove(57); // X
      game.applyMove(1);  // O
      game.applyMove(58); // X
      game.applyMove(2);  // O
      const result = game.applyMove(59); // X completes 4 in home side
      assertEquals(result.gameOver, false, 'Game should NOT be over (win in home side)');
      assertEquals(result.winner, undefined, 'No winner yet');
    });

    runner.test('Horizontal win in home side (O in top half) - INVALID', () => {
      const game = new GameEngine();
      // O attempts to win in row 0 (top half, O's home side) - should NOT count
      game.applyMove(32); // X
      game.applyMove(0);  // O
      game.applyMove(33); // X
      game.applyMove(1);  // O
      game.applyMove(34); // X
      game.applyMove(2);  // O
      game.applyMove(35); // X
      const result = game.applyMove(3);  // O completes 4 in home side
      assertEquals(result.gameOver, false, 'Game should NOT be over (win in home side)');
      assertEquals(result.winner, undefined, 'No winner yet');
    });

    runner.test('Horizontal win crossing halves - INVALID', () => {
      const game = new GameEngine();
      // Note: Horizontal lines can't actually cross halves since they're on the same row.
      // This test verifies that a horizontal line at the boundary is correctly categorized.
      // A line in row 3 (indices 24-31) is entirely in top half - would be valid for X
      // A line in row 4 (indices 32-39) is entirely in bottom half - would be valid for O
      // So horizontal lines are always in one half or the other.
      // This test simply confirms the game doesn't have false positives for partial wins.

      // Test: X gets 3 horizontal in a row in top half - should NOT win yet
      game.applyMove(24); // X row 3, col 0
      game.applyMove(32); // O
      game.applyMove(25); // X row 3, col 1
      game.applyMove(33); // O
      game.applyMove(26); // X row 3, col 2 (3 in a row)
      const result = game.applyMove(34); // O
      assertEquals(result.gameOver, false, 'Game should not end with only 3 in a row');
    });

    // Vertical win tests
    runner.section('Vertical Win Detection');

    runner.test('Vertical win in opponent side (X in top half) - VALID', () => {
      const game = new GameEngine();
      // X wins vertically in column 0, rows 0-3 (top half)
      // Indices: 0,8,16,24
      game.applyMove(0);  // X row 0
      game.applyMove(32); // O
      game.applyMove(8);  // X row 1
      game.applyMove(33); // O
      game.applyMove(16); // X row 2
      game.applyMove(34); // O
      const result = game.applyMove(24); // X row 3 - wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'X', 'X should win');
      assertArrayEquals(result.winningLine, [0, 8, 16, 24], 'Winning line should be vertical');
    });

    runner.test('Vertical win in opponent side (O in bottom half) - VALID', () => {
      const game = new GameEngine();
      // O wins vertically in column 7, rows 4-7 (bottom half)
      // Indices: 39,47,55,63
      game.applyMove(0);  // X
      game.applyMove(39); // O row 4
      game.applyMove(1);  // X
      game.applyMove(47); // O row 5
      game.applyMove(2);  // X
      game.applyMove(55); // O row 6
      game.applyMove(3);  // X
      const result = game.applyMove(63); // O row 7 - wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'O', 'O should win');
      assertArrayEquals(result.winningLine, [39, 47, 55, 63], 'Winning line should be vertical');
    });

    runner.test('Vertical win crossing halves - INVALID', () => {
      const game = new GameEngine();
      // X attempts vertical win from row 2-5 (crosses boundary between rows 3-4)
      // Column 0: indices 16,24,32,40
      game.applyMove(16); // X row 2 (top half)
      game.applyMove(0);  // O
      game.applyMove(24); // X row 3 (top half)
      game.applyMove(1);  // O
      game.applyMove(32); // X row 4 (bottom half)
      game.applyMove(2);  // O
      const result = game.applyMove(40); // X row 5 (bottom half) - crosses boundary
      assertEquals(result.gameOver, false, 'Game should NOT be over (win crosses halves)');
    });

    // Diagonal win tests
    runner.section('Diagonal Win Detection');

    runner.test('Diagonal win (down-right) in opponent side (X in top half) - VALID', () => {
      const game = new GameEngine();
      // X wins diagonally in top half
      // Indices: 0,9,18,27 (rows 0-3, cols 0-3)
      game.applyMove(0);  // X
      game.applyMove(32); // O
      game.applyMove(9);  // X
      game.applyMove(33); // O
      game.applyMove(18); // X
      game.applyMove(34); // O
      const result = game.applyMove(27); // X wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'X', 'X should win');
      assertArrayEquals(result.winningLine, [0, 9, 18, 27], 'Winning line should be diagonal');
    });

    runner.test('Diagonal win (down-left) in opponent side (O in bottom half) - VALID', () => {
      const game = new GameEngine();
      // O wins diagonally (down-left) in bottom half
      // Start at row 4, col 7: index 39
      // Indices: 39,46,53,60 (rows 4-7, cols 7,6,5,4)
      game.applyMove(0);  // X
      game.applyMove(39); // O
      game.applyMove(1);  // X
      game.applyMove(46); // O
      game.applyMove(2);  // X
      game.applyMove(53); // O
      game.applyMove(3);  // X
      const result = game.applyMove(60); // O wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'O', 'O should win');
      assertArrayEquals(result.winningLine, [39, 46, 53, 60], 'Winning line should be diagonal');
    });

    runner.test('Diagonal win crossing halves - INVALID', () => {
      const game = new GameEngine();
      // X attempts diagonal win crossing boundary
      // Indices: 16,25,34,43 (rows 2-5, cols 0-3) - crosses at rows 3-4
      game.applyMove(16); // X row 2 (top)
      game.applyMove(0);  // O
      game.applyMove(25); // X row 3 (top)
      game.applyMove(1);  // O
      game.applyMove(34); // X row 4 (bottom)
      game.applyMove(2);  // O
      const result = game.applyMove(43); // X row 5 (bottom) - crosses boundary
      assertEquals(result.gameOver, false, 'Game should NOT be over (diagonal crosses halves)');
    });

    // Edge and corner tests
    runner.section('Edge and Corner Cases');

    runner.test('Win in top-left corner (X) - VALID', () => {
      const game = new GameEngine();
      // Horizontal win in row 0, starting at col 0
      game.applyMove(0);  // X
      game.applyMove(32); // O
      game.applyMove(1);  // X
      game.applyMove(33); // O
      game.applyMove(2);  // X
      game.applyMove(34); // O
      const result = game.applyMove(3);  // X wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'X', 'X should win');
    });

    runner.test('Win in bottom-right corner (O) - VALID', () => {
      const game = new GameEngine();
      // Horizontal win in row 7, ending at col 7 (index 63)
      // Indices: 60,61,62,63
      game.applyMove(0);  // X
      game.applyMove(60); // O
      game.applyMove(1);  // X
      game.applyMove(61); // O
      game.applyMove(2);  // X
      game.applyMove(62); // O
      game.applyMove(3);  // X
      const result = game.applyMove(63); // O wins
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'O', 'O should win');
    });

    runner.test('Win at exact boundary (row 3) for X - VALID', () => {
      const game = new GameEngine();
      // X wins in row 3 (last row of top half)
      // Indices: 24,25,26,27
      game.applyMove(24); // X
      game.applyMove(32); // O
      game.applyMove(25); // X
      game.applyMove(33); // O
      game.applyMove(26); // X
      game.applyMove(34); // O
      const result = game.applyMove(27); // X wins at boundary
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'X', 'X should win at boundary row');
    });

    runner.test('Win at exact boundary (row 4) for O - VALID', () => {
      const game = new GameEngine();
      // O wins in row 4 (first row of bottom half)
      // Indices: 32,33,34,35
      game.applyMove(0);  // X
      game.applyMove(32); // O
      game.applyMove(1);  // X
      game.applyMove(33); // O
      game.applyMove(2);  // X
      game.applyMove(34); // O
      game.applyMove(3);  // X
      const result = game.applyMove(35); // O wins at boundary
      assert(result.gameOver, 'Game should be over');
      assertEquals(result.winner, 'O', 'O should win at boundary row');
    });

    // False positive tests
    runner.section('False Positive Prevention');

    runner.test('3-in-a-row does not trigger win', () => {
      const game = new GameEngine();
      // X gets 3 in a row but not 4
      game.applyMove(0);  // X
      game.applyMove(32); // O
      game.applyMove(1);  // X
      game.applyMove(33); // O
      const result = game.applyMove(2);  // X has 3 in a row
      assertEquals(result.gameOver, false, 'Game should NOT be over with only 3 in a row');
    });

    runner.test('Disconnected pieces do not trigger win', () => {
      const game = new GameEngine();
      // X: 0,1,3,4 (missing index 2)
      game.applyMove(0);  // X
      game.applyMove(32); // O
      game.applyMove(1);  // X
      game.applyMove(33); // O
      game.applyMove(3);  // X (skip 2)
      game.applyMove(34); // O
      const result = game.applyMove(4);  // X (not a valid line)
      assertEquals(result.gameOver, false, 'Disconnected pieces should not win');
    });

    runner.test('5-in-a-row in opponent side still wins (counts first 4)', () => {
      const game = new GameEngine();
      // X gets 5 in a row in top half
      game.applyMove(0);  // X
      game.applyMove(32); // O
      game.applyMove(1);  // X
      game.applyMove(33); // O
      game.applyMove(2);  // X
      game.applyMove(34); // O
      game.applyMove(3);  // X wins (4 in a row)
      assert(game.gameOver, 'Game should be over');
      // Even if they could place a 5th, the game is already over
    });

    runner.test('Draw detection when board is full', () => {
      const game = new GameEngine();
      // Fill board without creating a valid win
      // This is complex to set up manually, so we'll test the basic mechanism
      const moves = [];
      // Create a pattern that won't win for either player
      // We'll just verify draw detection works when board is full
      for (let i = 0; i < 64; i++) {
        moves.push(i);
      }

      // Shuffle to avoid wins (simplified test - just verify mechanism)
      let moveCount = 0;
      for (const move of moves) {
        if (game.gameOver) break;
        game.applyMove(move);
        moveCount++;
      }

      // If it's not a draw, at least verify the valid moves are tracked
      const validMoves = game.getValidMoves();
      assertEquals(validMoves.length, 64 - moveCount, 'Valid moves should decrease');
    });

    // Staged Opening + FIFO tests
    runner.section('Coin Toss + Alternating Halves + FIFO');

    runner.test('Coin toss sets starting player (X)', () => {
      // Force X to go first
      const game = new GameEngine({ rng: () => 0 });
      assertEquals(game.startingPlayer, 'X', 'Starting player should be X');
      assertEquals(game.currentPlayer, 'X', 'Current player should be X');
    });

    runner.test('Coin toss sets starting player (O)', () => {
      // Force O to go first
      const game = new GameEngine({ rng: () => 1 });
      assertEquals(game.startingPlayer, 'O', 'Starting player should be O');
      assertEquals(game.currentPlayer, 'O', 'Current player should be O');
    });

    runner.test('activeHalf initializes to opponent of starting player', () => {
      // X goes first -> O's half active (so X can place in opponent territory)
      const game1 = new GameEngine({ rng: () => 0 });
      assertEquals(game1.getActiveHalf(), 'O', 'Active half should be O when X starts');

      // O goes first -> X's half active (so O can place in opponent territory)
      const game2 = new GameEngine({ rng: () => 1 });
      assertEquals(game2.getActiveHalf(), 'X', 'Active half should be X when O starts');
    });

    runner.test('Can only place in active half', () => {
      const game = new GameEngine({ rng: () => 0 }); // X starts, O's half active

      // O's half (top, indices 0-31) should be valid
      assert(game.isValidMove(10), 'Index 10 (O half) should be valid');
      assert(game.isValidMove(20), 'Index 20 (O half) should be valid');

      // X's half (bottom, indices 32-63) should be invalid
      assert(!game.isValidMove(40), 'Index 40 (X half) should be invalid');
      assert(!game.isValidMove(50), 'Index 50 (X half) should be invalid');
    });

    runner.test('activeHalf toggles after each turn', () => {
      const game = new GameEngine({ rng: () => 0 }); // X starts, O's half active

      assertEquals(game.getActiveHalf(), 'O', 'Initial active half should be O (opponent)');

      // Turn 1: X places in O's half
      game.applyMove(10);
      assertEquals(game.getActiveHalf(), 'X', 'Active half should toggle to X');
      assertEquals(game.currentPlayer, 'O', 'Current player should be O');

      // Turn 2: O places in X's half
      game.applyMove(40);
      assertEquals(game.getActiveHalf(), 'O', 'Active half should toggle back to O');
      assertEquals(game.currentPlayer, 'X', 'Current player should be X');

      // Turn 3: X places in O's half
      game.applyMove(15);
      assertEquals(game.getActiveHalf(), 'X', 'Active half should toggle to X again');
      assertEquals(game.currentPlayer, 'O', 'Current player should be O');
    });

    runner.test('Legal moves filtered to active half only', () => {
      const game = new GameEngine({ rng: () => 0 }); // X starts, O's half active

      const validMoves = game.getValidMoves();

      // All valid moves should be in O's half (indices 0-31)
      validMoves.forEach(index => {
        assert(game.isInOHalf(index), `Valid move ${index} should be in O's half`);
      });

      // Place move and toggle to X's half
      game.applyMove(10);

      const validMovesX = game.getValidMoves();

      // All valid moves should now be in X's half (indices 32-63)
      validMovesX.forEach(index => {
        assert(game.isInXHalf(index), `Valid move ${index} should be in X's half`);
      });
    });

    runner.test('FIFO removal triggers when placing 4th piece (cap=3)', () => {
      const game = new GameEngine({ maxOnBoard: 3, rng: () => 0 }); // X starts, O's half active

      // Turn 1: X places in O's half (activeHalf toggles to X)
      game.applyMove(10); // X, ply 0
      // Turn 2: O places in X's half (activeHalf toggles to O)
      game.applyMove(40); // O, ply 1
      // Turn 3: X places in O's half (activeHalf toggles to X)
      game.applyMove(15); // X, ply 2
      // Turn 4: O places in X's half (activeHalf toggles to O)
      game.applyMove(45); // O, ply 3
      // Turn 5: X places in O's half (activeHalf toggles to X)
      game.applyMove(20); // X, ply 4
      // Turn 6: O places in X's half (activeHalf toggles to O)
      game.applyMove(50); // O, ply 5

      // X has 3 pieces (ply 0, 2, 4): indices 10, 15, 20
      // X places 4th piece in O's half -> should FIFO remove ply 0 (index 10)
      const result = game.applyMove(25); // X places 4th, ply 6

      assert(result.success, 'Move should succeed');
      assertEquals(result.fifoRemoved, 10, 'Should remove oldest piece (index 10)');
      assertEquals(game.board[10], game.EMPTY, 'Oldest piece should be removed');
      assertEquals(game.board[25], 'X', 'New piece should be placed');
      assertEquals(game.countPlayerPieces('X'), 3, 'X should still have 3 pieces after FIFO');
    });

    runner.test('FIFO removes oldest by plyIndex', () => {
      const game = new GameEngine({ maxOnBoard: 8, rng: () => 0 }); // X starts, O's half active

      // Alternating turns, active half alternates
      game.applyMove(10); // X in O's half, ply 0
      game.applyMove(40); // O in X's half, ply 1
      game.applyMove(15); // X in O's half, ply 2
      game.applyMove(45); // O in X's half, ply 3
      game.applyMove(20); // X in O's half, ply 4
      game.applyMove(50); // O in X's half, ply 5

      // X places 5 more to reach 8
      game.applyMove(25); // X, ply 6 (4th piece)
      game.applyMove(55); // O, ply 7
      game.applyMove(11); // X, ply 8 (5th piece)
      game.applyMove(41); // O, ply 9
      game.applyMove(16); // X, ply 10 (6th piece)
      game.applyMove(46); // O, ply 11
      game.applyMove(21); // X, ply 12 (7th piece)
      game.applyMove(51); // O, ply 13
      game.applyMove(26); // X, ply 14 (8th piece)

      assertEquals(game.countPlayerPieces('X'), 8, 'X should have 8 pieces');

      // X places 9th -> should remove oldest (ply 0, index 10)
      game.applyMove(56); // O, ply 15
      const result = game.applyMove(12); // X, ply 16 (9th piece)
      assertEquals(result.fifoRemoved, 10, 'Should remove ply 0 piece (oldest)');
    });

    runner.test('Win detection works with alternating halves', () => {
      const game = new GameEngine({ rng: () => 0 }); // X starts, O's half active

      // With corrected rules: X starts, O's half active
      // X places in O's half (where X needs to win)
      // O places in X's half (where O needs to win)

      // X builds 4-in-a-row in O's half (top, indices 0-7 is first row)
      game.applyMove(0);  // X in O's half, ply 0
      game.applyMove(32); // O in X's half, ply 1
      game.applyMove(1);  // X in O's half, ply 2
      game.applyMove(33); // O in X's half, ply 3
      game.applyMove(2);  // X in O's half, ply 4
      game.applyMove(34); // O in X's half, ply 5
      game.applyMove(3);  // X in O's half, ply 6 - X has 0,1,2,3 (4-in-a-row)!

      assert(game.gameOver, 'Game should be over');
      assertEquals(game.winner, 'X', 'X should win');
      assertArrayEquals(game.winningLine, [0, 1, 2, 3], 'Winning line should be 0,1,2,3');
    });

    runner.test('FIFO preview identifies correct piece', () => {
      const game = new GameEngine({ maxOnBoard: 3 });

      // Complete opening (3 pieces each)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X has 3 pieces at cap
      // Preview should show oldest piece (ply 0, index 40)
      const preview = game.getPieceToRemovePreview('X');
      assertEquals(preview, 40, 'Preview should identify oldest piece (index 40)');

      // O also has 3 pieces, preview should show ply 1, index 45
      const oPreview = game.getPieceToRemovePreview('O');
      assertEquals(oPreview, 45, 'Preview should identify oldest O piece (index 45)');
    });

    runner.test('Config: maxOnBoard is customizable', () => {
      const game1 = new GameEngine({ maxOnBoard: 5 });
      assertEquals(game1.MAX_ON_BOARD_PER_PLAYER, 5, 'Max should be configurable to 5');

      const game2 = new GameEngine({ maxOnBoard: 10 });
      assertEquals(game2.MAX_ON_BOARD_PER_PLAYER, 10, 'Max should be configurable to 10');

      const game3 = new GameEngine(); // Default
      assertEquals(game3.MAX_ON_BOARD_PER_PLAYER, 8, 'Default max should be 8');
    });

    // ============================================================
    // CPU PLAYER TESTS
    // ============================================================

    runner.section('CPU Player Tests');

    runner.test('CPU module initializes correctly', () => {
      const game = new GameEngine();
      const cpu = new CPUPlayer(game, 'easy');

      assert(cpu !== null, 'CPU should initialize');
      assertEquals(cpu.difficulty, 'easy', 'Difficulty should be set');
      assert(cpu.allSegments.length > 0, 'Segments should be precomputed');
    });

    runner.test('CPU chooses winning move when available', () => {
      const game = new GameEngine();
      const cpu = new CPUPlayer(game, 'easy');

      // Complete opening
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(35); // X, ply 2
      game.applyMove(10); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // Set up O's winning opportunity: 32, 33, 34 (needs 35 to win)
      game.applyMove(20); // X, ply 6
      game.applyMove(32); // O, ply 7
      game.applyMove(21); // X, ply 8
      game.applyMove(33); // O, ply 9
      game.applyMove(22); // X, ply 10
      game.applyMove(34); // O, ply 11

      // Now it's X's turn, but let's test that O would choose winning move
      game.currentPlayer = 'O';
      const move = cpu.getBestMove();

      // O should choose 35 to complete 32-33-34-35 horizontal win in X's half
      assertEquals(move, 35, 'CPU should choose winning move (index 35)');
    });

    runner.test('CPU blocks opponent immediate win', () => {
      const game = new GameEngine();
      const cpu = new CPUPlayer(game, 'easy');

      // Complete opening
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(0); // X, ply 2
      game.applyMove(50); // O, ply 3
      game.applyMove(35); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X builds threat: 0, 1, 2 (needs 3 to win in O's half)
      game.applyMove(1); // X, ply 6
      game.applyMove(32); // O, ply 7
      game.applyMove(2); // X, ply 8

      // O's turn - should block at 3
      game.currentPlayer = 'O';
      const move = cpu.getBestMove();

      assertEquals(move, 3, 'CPU should block X winning move at index 3');
    });

    runner.test('CPU respects opening phase restrictions', () => {
      const game = new GameEngine();
      const cpu = new CPUPlayer(game, 'easy');

      // Ply 0: X must place in X's half
      const move0 = cpu.getBestMove();
      assert(move0 > 31, 'CPU move in opening ply 0 should be in X half (> 31)');

      game.applyMove(move0); // X

      // Ply 1: O must place in X's half
      game.currentPlayer = 'O';
      const move1 = cpu.getBestMove();
      assert(move1 > 31, 'CPU move in opening ply 1 should be in X half (> 31)');

      game.applyMove(move1); // O

      // Ply 2: X must place in O's half
      game.currentPlayer = 'X';
      const move2 = cpu.getBestMove();
      assert(move2 <= 31, 'CPU move in opening ply 2 should be in O half (<= 31)');
    });

    runner.test('CPU move selection is deterministic', () => {
      const game1 = new GameEngine();
      const cpu1 = new CPUPlayer(game1, 'medium');

      const game2 = new GameEngine();
      const cpu2 = new CPUPlayer(game2, 'medium');

      // Same initial state should produce same move
      const move1 = cpu1.getBestMove();
      const move2 = cpu2.getBestMove();

      assertEquals(move1, move2, 'CPU should be deterministic - same state produces same move');
    });

    runner.test('CPU handles FIFO removal correctly', () => {
      const game = new GameEngine({ maxOnBoard: 4 });
      const cpu = new CPUPlayer(game, 'medium');

      // Complete opening with 3 pieces each
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X places 4th piece (at cap)
      game.applyMove(20); // X, ply 6

      // O's turn - O will place 4th piece and be at cap
      game.currentPlayer = 'O';
      const move = cpu.getBestMove();
      const result = game.applyMove(move);

      assert(result.success, 'CPU move should succeed');
      assertEquals(game.countPlayerPieces('O'), 4, 'O should still have 4 pieces after move');

      // O places 5th piece, should trigger FIFO
      game.currentPlayer = 'O';
      const move2 = cpu.getBestMove();
      const result2 = game.applyMove(move2);

      assert(result2.fifoRemoved !== null, 'FIFO should trigger when exceeding cap');
      assertEquals(game.countPlayerPieces('O'), 4, 'O should have 4 pieces after FIFO removal');
    });

    runner.test('CPU difficulty levels produce different search depths', () => {
      const game = new GameEngine();

      const cpuEasy = new CPUPlayer(game, 'easy');
      const cpuMedium = new CPUPlayer(game, 'medium');
      const cpuHard = new CPUPlayer(game, 'hard');

      assertEquals(cpuEasy.difficulty, 'easy', 'Easy difficulty set');
      assertEquals(cpuMedium.difficulty, 'medium', 'Medium difficulty set');
      assertEquals(cpuHard.difficulty, 'hard', 'Hard difficulty set');

      // All should return valid moves
      const moveEasy = cpuEasy.getBestMove();
      const moveMedium = cpuMedium.getBestMove();
      const moveHard = cpuHard.getBestMove();

      assert(moveEasy !== null, 'Easy should return a move');
      assert(moveMedium !== null, 'Medium should return a move');
      assert(moveHard !== null, 'Hard should return a move');
    });

    runner.test('CPU predictFifoRemoval helper works correctly', () => {
      const game = new GameEngine({ maxOnBoard: 3 });

      // Complete opening (3 pieces each)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X has 3 pieces at cap, next placement should trigger FIFO
      const predicted = game.predictFifoRemoval('X', 20);
      assertEquals(predicted, 40, 'Should predict removal of oldest X piece (index 40)');

      // O also at cap
      const predictedO = game.predictFifoRemoval('O', 20);
      assertEquals(predictedO, 45, 'Should predict removal of oldest O piece (index 45)');
    });

    runner.test('CPU clone method preserves state', () => {
      const game = new GameEngine();

      // Make some moves
      game.applyMove(40);
      game.applyMove(45);
      game.applyMove(10);

      // Clone the game
      const cloned = game.clone();

      // Verify state is preserved
      assertArrayEquals(cloned.board, game.board, 'Board should be cloned');
      assertEquals(cloned.currentPlayer, game.currentPlayer, 'Current player should be cloned');
      assertEquals(cloned.phase, game.phase, 'Phase should be cloned');
      assertEquals(cloned.plyCount, game.plyCount, 'Ply count should be cloned');

      // Verify clones are independent
      cloned.applyMove(15);
      assert(cloned.plyCount !== game.plyCount, 'Clones should be independent');
    });

    // ============================================================
    // FIFO VISIBILITY TESTS
    // ============================================================

    runner.section('FIFO Visibility Tests');

    runner.test('getNextOutPiece returns oldest piece for each player', () => {
      const game = new GameEngine();

      // Initially no pieces
      assertEquals(game.getNextOutPiece('X'), null, 'X should have no next-out initially');
      assertEquals(game.getNextOutPiece('O'), null, 'O should have no next-out initially');

      // Place some pieces
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3

      // X's oldest is at index 40 (ply 0)
      assertEquals(game.getNextOutPiece('X'), 40, 'X next-out should be index 40 (oldest)');

      // O's oldest is at index 45 (ply 1)
      assertEquals(game.getNextOutPiece('O'), 45, 'O next-out should be index 45 (oldest)');
    });

    runner.test('getNextOutPiece updates after FIFO removal', () => {
      const game = new GameEngine({ maxOnBoard: 3 });

      // Complete opening (3 pieces each)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X's next-out is index 40 (ply 0)
      assertEquals(game.getNextOutPiece('X'), 40, 'X next-out should be 40 before FIFO');

      // X places 4th piece, triggers FIFO removal of index 40
      game.applyMove(20); // X, ply 6

      // Now X's oldest is index 10 (ply 2)
      assertEquals(game.getNextOutPiece('X'), 10, 'X next-out should be 10 after FIFO removed 40');
    });

    runner.test('getMoveRemovalPreview returns pieces for FIFO move', () => {
      const game = new GameEngine({ maxOnBoard: 3 });

      // Complete opening (3 pieces each)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X is at cap (3/3), placing at index 20 should trigger FIFO
      const preview = game.getMoveRemovalPreview(20);

      assertEquals(preview.removedPieces.length, 1, 'Should preview 1 removal');
      assertEquals(preview.removedPieces[0].player, 'X', 'Removed piece should be X');
      assertEquals(preview.removedPieces[0].index, 40, 'Should remove oldest X piece (index 40)');
      assertEquals(preview.removedPieces[0].reason, 'fifo', 'Removal reason should be FIFO');
    });

    runner.test('getMoveRemovalPreview returns empty for non-FIFO move', () => {
      const game = new GameEngine({ maxOnBoard: 8 });

      // Place a few pieces (not at cap)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X has 3 pieces (not at cap of 8), placing at index 20 should NOT trigger FIFO
      const preview = game.getMoveRemovalPreview(20);

      assertEquals(preview.removedPieces.length, 0, 'Should preview no removals when not at cap');
    });

    runner.test('getMoveRemovalPreview during opening phase returns empty', () => {
      const game = new GameEngine({ maxOnBoard: 3 });

      // During opening phase, FIFO doesn't trigger
      const preview1 = game.getMoveRemovalPreview(40);
      assertEquals(preview1.removedPieces.length, 0, 'No FIFO during opening phase (ply 0)');

      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1

      const preview2 = game.getMoveRemovalPreview(10);
      assertEquals(preview2.removedPieces.length, 0, 'No FIFO during opening phase (ply 2)');
    });

    runner.test('getMoveRemovalPreview returns empty for invalid moves', () => {
      const game = new GameEngine();

      // Complete opening
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // Try to preview an occupied cell
      const preview1 = game.getMoveRemovalPreview(40);
      assertEquals(preview1.removedPieces.length, 0, 'Invalid move (occupied) should return no preview');

      // Try to preview out of bounds
      const preview2 = game.getMoveRemovalPreview(-1);
      assertEquals(preview2.removedPieces.length, 0, 'Invalid move (out of bounds) should return no preview');

      const preview3 = game.getMoveRemovalPreview(100);
      assertEquals(preview3.removedPieces.length, 0, 'Invalid move (out of bounds) should return no preview');
    });

    runner.test('FIFO visibility helpers are deterministic', () => {
      const game1 = new GameEngine({ maxOnBoard: 3 });
      const game2 = new GameEngine({ maxOnBoard: 3 });

      // Make same moves in both games
      for (const index of [40, 45, 10, 15, 50, 55]) {
        game1.applyMove(index);
        game2.applyMove(index);
      }

      // getNextOutPiece should return same result
      assertEquals(game1.getNextOutPiece('X'), game2.getNextOutPiece('X'), 'getNextOutPiece should be deterministic for X');
      assertEquals(game1.getNextOutPiece('O'), game2.getNextOutPiece('O'), 'getNextOutPiece should be deterministic for O');

      // getMoveRemovalPreview should return same result
      const preview1 = game1.getMoveRemovalPreview(20);
      const preview2 = game2.getMoveRemovalPreview(20);

      assertEquals(preview1.removedPieces.length, preview2.removedPieces.length, 'Preview length should match');
      if (preview1.removedPieces.length > 0) {
        assertEquals(preview1.removedPieces[0].index, preview2.removedPieces[0].index, 'Preview index should match');
      }
    });

    // ============================================================
    // FIFO ORDERING TESTS (for warning highlights)
    // ============================================================

    runner.section('FIFO Ordering Tests');

    runner.test('getFifoOrder returns pieces in correct oldest-first order', () => {
      const game = new GameEngine();

      // Place pieces in specific order
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X has pieces at: 40 (ply 0), 10 (ply 2), 50 (ply 4)
      const xFifo = game.getFifoOrder('X');
      assertArrayEquals(xFifo, [40, 10, 50], 'X FIFO order should be oldest first');

      // O has pieces at: 45 (ply 1), 15 (ply 3), 55 (ply 5)
      const oFifo = game.getFifoOrder('O');
      assertArrayEquals(oFifo, [45, 15, 55], 'O FIFO order should be oldest first');
    });

    runner.test('getFifoOrder with count parameter returns top N pieces', () => {
      const game = new GameEngine();

      // Place pieces
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // Get top 2 oldest for X
      const xTop2 = game.getFifoOrder('X', 2);
      assertEquals(xTop2.length, 2, 'Should return exactly 2 pieces');
      assertArrayEquals(xTop2, [40, 10], 'X top 2 should be oldest pieces');

      // Get top 2 oldest for O
      const oTop2 = game.getFifoOrder('O', 2);
      assertEquals(oTop2.length, 2, 'Should return exactly 2 pieces');
      assertArrayEquals(oTop2, [45, 15], 'O top 2 should be oldest pieces');
    });

    runner.test('getFifoOrder returns empty array when player has no pieces', () => {
      const game = new GameEngine();

      const xFifo = game.getFifoOrder('X');
      assertEquals(xFifo.length, 0, 'Should return empty array for X initially');

      const oFifo = game.getFifoOrder('O');
      assertEquals(oFifo.length, 0, 'Should return empty array for O initially');
    });

    runner.test('getFifoOrder updates correctly after FIFO removal', () => {
      const game = new GameEngine({ maxOnBoard: 3 });

      // Complete opening (3 pieces each)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // X has: 40 (ply 0), 10 (ply 2), 50 (ply 4)
      const xFifoBefore = game.getFifoOrder('X');
      assertArrayEquals(xFifoBefore, [40, 10, 50], 'X FIFO before removal');

      // X places 4th piece, triggers FIFO removal of index 40
      game.applyMove(20); // X, ply 6

      // Now X has: 10 (ply 2), 50 (ply 4), 20 (ply 6)
      const xFifoAfter = game.getFifoOrder('X');
      assertArrayEquals(xFifoAfter, [10, 50, 20], 'X FIFO should update after removal');
    });

    runner.test('getFifoOrder handles player with only 1 piece', () => {
      const game = new GameEngine();

      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1

      const xFifo = game.getFifoOrder('X', 2);
      assertEquals(xFifo.length, 1, 'Should return 1 piece when only 1 exists');
      assertArrayEquals(xFifo, [40], 'Should return the single piece');

      const oFifo = game.getFifoOrder('O', 2);
      assertEquals(oFifo.length, 1, 'Should return 1 piece when only 1 exists');
      assertArrayEquals(oFifo, [45], 'Should return the single piece');
    });

    runner.test('getFifoOrder is deterministic', () => {
      const game1 = new GameEngine();
      const game2 = new GameEngine();

      // Make same moves in both games
      for (const index of [40, 45, 10, 15, 50, 55]) {
        game1.applyMove(index);
        game2.applyMove(index);
      }

      // Results should be identical
      const xFifo1 = game1.getFifoOrder('X');
      const xFifo2 = game2.getFifoOrder('X');
      assertArrayEquals(xFifo1, xFifo2, 'X FIFO order should be deterministic');

      const oFifo1 = game1.getFifoOrder('O');
      const oFifo2 = game2.getFifoOrder('O');
      assertArrayEquals(oFifo1, oFifo2, 'O FIFO order should be deterministic');
    });

    // ============================================================
    // FIFO WARNINGS GATING TESTS (per-player flag)
    // ============================================================

    runner.section('FIFO Warnings Gating Tests');

    runner.test('FIFO warnings disabled before player reaches cap', () => {
      const game = new GameEngine();

      // Initially disabled for both players
      assertEquals(game.isFifoWarningsEnabled('X'), false, 'X warnings should be disabled initially');
      assertEquals(game.isFifoWarningsEnabled('O'), false, 'O warnings should be disabled initially');

      // Complete opening (3 pieces each) - still below cap
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // Both players have 3 pieces, below cap (8), warnings still disabled
      assertEquals(game.isFifoWarningsEnabled('X'), false, 'X warnings should be disabled below cap');
      assertEquals(game.isFifoWarningsEnabled('O'), false, 'O warnings should be disabled below cap');

      // Add more pieces, still below cap
      game.applyMove(20); // X, ply 6 (4 pieces)
      assertEquals(game.isFifoWarningsEnabled('X'), false, 'X warnings disabled at 4 pieces');

      game.applyMove(25); // O, ply 7 (4 pieces)
      assertEquals(game.isFifoWarningsEnabled('O'), false, 'O warnings disabled at 4 pieces');
    });

    runner.test('FIFO warnings enabled exactly when player reaches cap', () => {
      const game = new GameEngine();

      // Complete opening (3 pieces each)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // Add pieces up to cap - 1
      game.applyMove(20); // X, ply 6 (4 pieces)
      game.applyMove(25); // O, ply 7 (4 pieces)
      game.applyMove(30); // X, ply 8 (5 pieces)
      game.applyMove(35); // O, ply 9 (5 pieces)
      game.applyMove(41); // X, ply 10 (6 pieces)
      game.applyMove(46); // O, ply 11 (6 pieces)
      game.applyMove(11); // X, ply 12 (7 pieces)
      game.applyMove(16); // O, ply 13 (7 pieces)

      // Both have 7 pieces, still disabled
      assertEquals(game.isFifoWarningsEnabled('X'), false, 'X warnings disabled at 7 pieces');
      assertEquals(game.isFifoWarningsEnabled('O'), false, 'O warnings disabled at 7 pieces');

      // X reaches cap (8 pieces)
      game.applyMove(51); // X, ply 14 (8 pieces)
      assertEquals(game.isFifoWarningsEnabled('X'), true, 'X warnings enabled at 8 pieces');
      assertEquals(game.isFifoWarningsEnabled('O'), false, 'O warnings still disabled');

      // O reaches cap (8 pieces)
      game.applyMove(56); // O, ply 15 (8 pieces)
      assertEquals(game.isFifoWarningsEnabled('O'), true, 'O warnings enabled at 8 pieces');
    });

    runner.test('FIFO warnings remain enabled after FIFO removals', () => {
      const game = new GameEngine({ maxOnBoard: 3 });

      // Complete opening (3 pieces each, at cap)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // Both at cap, warnings enabled
      assertEquals(game.isFifoWarningsEnabled('X'), true, 'X warnings enabled at cap');
      assertEquals(game.isFifoWarningsEnabled('O'), true, 'O warnings enabled at cap');

      // X places 4th piece, triggers FIFO removal (back to 3 pieces)
      game.applyMove(20); // X, ply 6 (triggers FIFO)
      assertEquals(game.countPlayerPieces('X'), 3, 'X should have 3 pieces after FIFO');
      assertEquals(game.isFifoWarningsEnabled('X'), true, 'X warnings still enabled after FIFO');

      // O places 4th piece, triggers FIFO removal (back to 3 pieces)
      game.applyMove(25); // O, ply 7 (triggers FIFO)
      assertEquals(game.countPlayerPieces('O'), 3, 'O should have 3 pieces after FIFO');
      assertEquals(game.isFifoWarningsEnabled('O'), true, 'O warnings still enabled after FIFO');
    });

    runner.test('FIFO warnings per-player independence', () => {
      const game = new GameEngine();

      // Complete opening (3 pieces each)
      game.applyMove(40); // X, ply 0
      game.applyMove(45); // O, ply 1
      game.applyMove(10); // X, ply 2
      game.applyMove(15); // O, ply 3
      game.applyMove(50); // X, ply 4
      game.applyMove(55); // O, ply 5

      // Add pieces for X up to cap
      game.applyMove(20); // X, ply 6 (4 pieces)
      game.applyMove(25); // O, ply 7 (4 pieces)
      game.applyMove(30); // X, ply 8 (5 pieces)
      game.applyMove(35); // O, ply 9 (5 pieces)
      game.applyMove(41); // X, ply 10 (6 pieces)
      game.applyMove(46); // O, ply 11 (6 pieces)
      game.applyMove(11); // X, ply 12 (7 pieces)
      game.applyMove(26); // O, ply 13 (7 pieces)
      game.applyMove(51); // X, ply 14 (8 pieces - reaches cap!)

      // Only X should have warnings enabled
      assertEquals(game.isFifoWarningsEnabled('X'), true, 'X warnings enabled');
      assertEquals(game.isFifoWarningsEnabled('O'), false, 'O warnings still disabled');
      assertEquals(game.countPlayerPieces('O'), 7, 'O should have 7 pieces');

      // Continue without O reaching cap
      game.applyMove(36); // O, ply 15 (8 pieces - O reaches cap!)
      assertEquals(game.isFifoWarningsEnabled('O'), true, 'O warnings now enabled');
    });

    // Run all tests
    runner.run();
  </script>
</body>
</html>
