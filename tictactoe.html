<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tic-Tac-Toe</title>
  <style>
    :root {
      color-scheme: light;
      --bg: linear-gradient(135deg, #e8f0ff 0%, #fdf6ff 55%, #f4fbff 100%);
      --panel: #ffffff;
      --line: #c9d4e5;
      --accent: #2f5fe8;
      --x: #1b6ef3;
      --o: #e84a5f;
      --muted: #5c667a;
      --win: #20b26b;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: #1d2433;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      touch-action: manipulation;
      overscroll-behavior: none;
      -webkit-text-size-adjust: 100%;
    }

    .game {
      background: var(--panel);
      padding: 28px;
      border-radius: 18px;
      box-shadow: 0 20px 40px rgba(25, 35, 57, 0.12);
      width: min(420px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      text-align: center;
      transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
    }

    .game.over {
      background: #f8faff;
      box-shadow: 0 24px 50px rgba(25, 35, 57, 0.18);
    }

    .game.win {
      animation: celebrate 0.9s ease-in-out;
    }

    h1 {
      margin: 0;
      font-size: 1.8rem;
    }

    .scoreboard {
      width: 100%;
      background: #eff3ff;
      border-radius: 16px;
      padding: 12px 16px;
      font-weight: 700;
      color: #1d2433;
      box-shadow: inset 0 0 0 1px rgba(201, 212, 229, 0.9);
    }

    .scoreboard span {
      color: var(--accent);
    }

    .game-state {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--muted);
      padding: 6px 12px;
      border-radius: 999px;
      background: #f4f7ff;
      border: 1px solid rgba(201, 212, 229, 0.8);
    }

    .game-state.over {
      color: #fff;
      background: var(--win);
      border-color: transparent;
    }

    .turn-indicator {
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
      font-size: 0.9rem;
      font-weight: 600;
    }

    .turn-indicator .token {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
      background: #f6f8ff;
      transition: all 0.2s ease;
    }

    .turn-indicator .token.active {
      color: #fff;
      border-color: transparent;
      box-shadow: 0 6px 16px rgba(47, 95, 232, 0.25);
    }

    .turn-indicator .token.x.active {
      background: var(--x);
    }

    .turn-indicator .token.o.active {
      background: var(--o);
    }

    #status {
      font-size: 1rem;
      color: var(--muted);
      min-height: 1.4em;
      transition: color 0.2s ease;
    }

    #status.thinking::after {
      content: "";
      display: inline-block;
      width: 8px;
      height: 8px;
      margin-left: 8px;
      border-radius: 50%;
      background: var(--accent);
      animation: pulse 0.9s ease-in-out infinite;
      vertical-align: middle;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(3, minmax(70px, 1fr));
      grid-template-rows: repeat(3, minmax(70px, 1fr));
      gap: 8px;
      width: 100%;
      max-width: 360px;
      padding: 8px;
      border-radius: 16px;
      background: #f5f7ff;
      box-shadow: inset 0 0 0 1px rgba(201, 212, 229, 0.6), 0 12px 24px rgba(27, 51, 106, 0.12);
    }

    .board.disabled {
      pointer-events: none;
      opacity: 0.9;
    }

    .cell {
      background: #fdfdff;
      border: 2px solid var(--line);
      border-radius: 12px;
      font-size: clamp(2.4rem, 7vw, 3.2rem);
      font-weight: 800;
      color: #1d2433;
      cursor: pointer;
      transition: transform 0.15s ease, border-color 0.2s ease, background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      min-width: 44px;
      min-height: 44px;
      touch-action: manipulation;
    }

    .cell.filled {
      animation: fadeIn 0.3s ease-out;
    }

    .cell.x {
      color: var(--x);
      text-shadow: 0 6px 14px rgba(27, 110, 243, 0.35);
    }

    .cell.o {
      color: var(--o);
      text-shadow: 0 6px 14px rgba(232, 74, 95, 0.35);
    }

    .cell.empty:hover {
      border-color: var(--accent);
      transform: scale(1.04);
      background: #f2f6ff;
    }

    .cell:active {
      transform: scale(0.96);
      box-shadow: 0 0 0 6px rgba(47, 95, 232, 0.18);
    }

    .cell:disabled {
      cursor: not-allowed;
      opacity: 0.8;
      background: #f8f9ff;
    }

    .cell.winning {
      border-color: var(--win);
      box-shadow: 0 0 0 2px rgba(32, 178, 107, 0.25);
      animation: glow 1s ease-in-out infinite;
    }

    .game.over .cell {
      cursor: not-allowed;
      opacity: 0.9;
    }

    .game.over .cell.empty:hover {
      transform: none;
      border-color: var(--line);
      background: #fdfdff;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .button {
      border: none;
      background: var(--accent);
      color: #fff;
      padding: 12px 20px;
      border-radius: 999px;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease, opacity 0.3s ease;
      min-height: 44px;
      touch-action: manipulation;
    }

    .button.secondary {
      background: #eef1fb;
      color: #1d2433;
      border: 1px solid rgba(201, 212, 229, 0.9);
    }

    .controls .play-again {
      opacity: 0;
      pointer-events: none;
      transform: translateY(6px);
    }

    .game.over .controls .play-again {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .button:hover {
      transform: translateY(-2px) scale(1.01);
      box-shadow: 0 10px 20px rgba(47, 95, 232, 0.2);
    }

    .button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .move-history {
      width: 100%;
      background: #f9faff;
      border-radius: 14px;
      padding: 10px 14px;
      border: 1px solid rgba(201, 212, 229, 0.7);
      max-height: 140px;
      overflow-y: auto;
      text-align: left;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .move-history strong {
      color: #1d2433;
    }

    .move-history ul {
      list-style: none;
      padding: 0;
      margin: 8px 0 0;
      display: grid;
      gap: 4px;
    }

    .move-history li {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .message-win {
      color: var(--win);
      font-weight: 600;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes pulse {
      0%,
      100% {
        transform: scale(0.8);
        opacity: 0.6;
      }
      50% {
        transform: scale(1.2);
        opacity: 1;
      }
    }

    @keyframes glow {
      0%,
      100% {
        box-shadow: 0 0 0 2px rgba(32, 178, 107, 0.25);
      }
      50% {
        box-shadow: 0 0 12px rgba(32, 178, 107, 0.5);
      }
    }

    @keyframes celebrate {
      0% {
        transform: scale(1);
      }
      40% {
        transform: scale(1.02);
      }
      100% {
        transform: scale(1);
      }
    }

    @media (max-width: 480px) {
      .game {
        padding: 22px 18px;
      }

      h1 {
        font-size: 1.5rem;
      }

      .controls {
        width: 100%;
      }

      .button {
        flex: 1 1 140px;
      }
    }
  </style>
</head>
<body>
  <main class="game" id="game">
    <h1>Tic-Tac-Toe</h1>
    <div class="scoreboard" id="scoreboard">
      Player: <span id="score-player">0</span> wins | Computer: <span id="score-computer">0</span> wins | Draws: <span id="score-draws">0</span>
    </div>
    <div class="game-state" id="game-state">In progress</div>
    <div class="turn-indicator" aria-label="Current turn">
      <span class="token x" id="turn-x">X Player</span>
      <span class="token o" id="turn-o">O Computer</span>
    </div>
    <div id="status">Your turn: place an X.</div>
    <div class="board" id="board" aria-label="Tic-tac-toe board"></div>
    <div class="move-history" id="move-history">
      <strong>Move History</strong>
      <ul id="move-list"></ul>
    </div>
    <div class="controls">
      <button class="button play-again" id="reset">Play Again</button>
      <button class="button secondary" id="reset-score">Reset Score</button>
      <button class="button secondary" id="sound-toggle" aria-pressed="true">Sound: On</button>
    </div>
  </main>

  <script>
    const PLAYER = "X";
    const COMPUTER = "O";
    const EMPTY = "";

    const boardElement = document.getElementById("board");
    const statusElement = document.getElementById("status");
    const resetButton = document.getElementById("reset");
    const resetScoreButton = document.getElementById("reset-score");
    const gameElement = document.getElementById("game");
    const turnXElement = document.getElementById("turn-x");
    const turnOElement = document.getElementById("turn-o");
    const scoreboardPlayer = document.getElementById("score-player");
    const scoreboardComputer = document.getElementById("score-computer");
    const scoreboardDraws = document.getElementById("score-draws");
    const gameStateElement = document.getElementById("game-state");
    const moveListElement = document.getElementById("move-list");
    const soundToggleButton = document.getElementById("sound-toggle");

    let board = Array(9).fill(EMPTY);
    let currentPlayer = PLAYER;
    let gameOver = false;
    let aiTimeoutId = null;
    let winningLine = null;
    let moveHistory = [];
    let soundEnabled = true;
    // Session-only score tracking (persists across games in the same tab).
    const SCORE_KEY = "tictactoeScores";
    let scores = {
      player: 0,
      computer: 0,
      draws: 0
    };

    const winLines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6]
    ];

    function renderBoard() {
      boardElement.innerHTML = "";
      boardElement.classList.toggle("disabled", currentPlayer === COMPUTER || gameOver);
      board.forEach((value, index) => {
        const cell = document.createElement("button");
        cell.type = "button";
        const baseClass = value ? value.toLowerCase() : "empty";
        const filledClass = value ? "filled" : "";
        const isWinning = winningLine && winningLine.includes(index);
        cell.className = `cell ${baseClass} ${filledClass} ${isWinning ? "winning" : ""}`.trim();
        cell.textContent = value;
        cell.setAttribute("data-index", index);
        cell.addEventListener("click", handlePlayerMove);
        cell.disabled = value !== EMPTY || gameOver || currentPlayer !== PLAYER;
        boardElement.appendChild(cell);
      });
    }

    function updateStatus(message, isWin = false, isThinking = false) {
      statusElement.textContent = message;
      statusElement.classList.toggle("message-win", isWin);
      statusElement.classList.toggle("thinking", isThinking);
    }

    function updateTurnIndicator() {
      const isPlayerTurn = currentPlayer === PLAYER && !gameOver;
      const isComputerTurn = currentPlayer === COMPUTER && !gameOver;
      turnXElement.classList.toggle("active", isPlayerTurn);
      turnOElement.classList.toggle("active", isComputerTurn);
    }

    function updateGameState() {
      const label = gameOver ? "Game over" : "In progress";
      gameStateElement.textContent = label;
      gameStateElement.classList.toggle("over", gameOver);
    }

    function loadScores() {
      const stored = sessionStorage.getItem(SCORE_KEY);
      if (stored) {
        try {
          scores = JSON.parse(stored);
        } catch (error) {
          scores = { player: 0, computer: 0, draws: 0 };
        }
      }
      updateScoreboard();
    }

    function saveScores() {
      sessionStorage.setItem(SCORE_KEY, JSON.stringify(scores));
    }

    function updateScoreboard() {
      scoreboardPlayer.textContent = scores.player;
      scoreboardComputer.textContent = scores.computer;
      scoreboardDraws.textContent = scores.draws;
    }

    // Track moves for quick post-game review.
    function addMoveHistory(symbol, index) {
      const row = Math.floor(index / 3) + 1;
      const col = (index % 3) + 1;
      moveHistory.push({ symbol, row, col });
      renderMoveHistory();
    }

    function renderMoveHistory() {
      moveListElement.innerHTML = "";
      if (moveHistory.length === 0) {
        return;
      }
      moveHistory.forEach((move, idx) => {
        const item = document.createElement("li");
        item.textContent = `${idx + 1}. ${move.symbol}`;
        const position = document.createElement("span");
        position.textContent = `Row ${move.row}, Col ${move.col}`;
        item.appendChild(position);
        moveListElement.appendChild(item);
      });
    }

    function updateSoundToggle() {
      soundToggleButton.textContent = `Sound: ${soundEnabled ? "On" : "Off"}`;
      soundToggleButton.setAttribute("aria-pressed", String(soundEnabled));
    }

    function getWinningLine(state, symbol) {
      return winLines.find(line => line.every(index => state[index] === symbol)) || null;
    }

    function checkWin(state, symbol) {
      return winLines.some(line => line.every(index => state[index] === symbol));
    }

    function checkDraw(state) {
      return state.every(cell => cell !== EMPTY);
    }

    function getAvailableMoves(state) {
      return state
        .map((value, index) => (value === EMPTY ? index : null))
        .filter(index => index !== null);
    }

    function minimax(state, isMaximizing) {
      if (checkWin(state, COMPUTER)) {
        return { score: 1 };
      }
      if (checkWin(state, PLAYER)) {
        return { score: -1 };
      }
      if (checkDraw(state)) {
        return { score: 0 };
      }

      const availableMoves = getAvailableMoves(state);
      let bestMove = null;
      let bestScore = isMaximizing ? -Infinity : Infinity;

      availableMoves.forEach(move => {
        state[move] = isMaximizing ? COMPUTER : PLAYER;
        const { score } = minimax(state, !isMaximizing);
        state[move] = EMPTY;

        if (isMaximizing && score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
        if (!isMaximizing && score < bestScore) {
          bestScore = score;
          bestMove = move;
        }
      });

      return { score: bestScore, move: bestMove };
    }

    function finishGame(message, { isWin = false, result = "draw" } = {}) {
      gameOver = true;
      gameElement.classList.add("over");
      gameElement.classList.toggle("win", isWin);
      updateStatus(message, isWin, false);
      updateTurnIndicator();
      updateGameState();
      if (result === "player") {
        scores.player += 1;
      } else if (result === "computer") {
        scores.computer += 1;
      } else {
        scores.draws += 1;
      }
      saveScores();
      updateScoreboard();
    }

    function handlePlayerMove(event) {
      if (gameOver || currentPlayer !== PLAYER) {
        return;
      }

      const index = Number(event.currentTarget.getAttribute("data-index"));
      if (board[index] !== EMPTY) {
        return;
      }

      board[index] = PLAYER;
      winningLine = getWinningLine(board, PLAYER);
      addMoveHistory(PLAYER, index);

      if (winningLine) {
        renderBoard();
        finishGame("You win!", { isWin: true, result: "player" });
        return;
      }

      if (checkDraw(board)) {
        renderBoard();
        finishGame("It\'s a draw.", { result: "draw" });
        return;
      }

      currentPlayer = COMPUTER;
      renderBoard();
      updateStatus("Computer is thinking...", false, true);
      updateTurnIndicator();
      updateGameState();
      aiTimeoutId = setTimeout(() => {
        aiTimeoutId = null;
        handleComputerMove();
      }, 400);
    }

    function handleComputerMove() {
      if (gameOver || currentPlayer !== COMPUTER) {
        return;
      }

      const { move } = minimax([...board], true);
      const selectedMove = move ?? getAvailableMoves(board)[0];
      if (selectedMove === undefined) {
        finishGame("It\'s a draw.", { result: "draw" });
        return;
      }

      board[selectedMove] = COMPUTER;
      winningLine = getWinningLine(board, COMPUTER);
      addMoveHistory(COMPUTER, selectedMove);
      if (winningLine) {
        renderBoard();
        finishGame("Computer wins.", { isWin: true, result: "computer" });
        return;
      }

      if (checkDraw(board)) {
        renderBoard();
        finishGame("It\'s a draw.", { result: "draw" });
        return;
      }

      currentPlayer = PLAYER;
      renderBoard();
      updateStatus("Your turn: place an X.");
      updateTurnIndicator();
      updateGameState();
    }

    function resetGame() {
      if (aiTimeoutId !== null) {
        clearTimeout(aiTimeoutId);
        aiTimeoutId = null;
      }
      board = Array(9).fill(EMPTY);
      currentPlayer = PLAYER;
      gameOver = false;
      winningLine = null;
      moveHistory = [];
      gameElement.classList.remove("over");
      gameElement.classList.remove("win");
      updateStatus("Your turn: place an X.");
      renderBoard();
      updateTurnIndicator();
      updateGameState();
      renderMoveHistory();
    }

    resetButton.addEventListener("click", resetGame);
    resetScoreButton.addEventListener("click", () => {
      if (!confirm("Reset all scores back to 0?")) {
        return;
      }
      scores = { player: 0, computer: 0, draws: 0 };
      saveScores();
      updateScoreboard();
    });
    soundToggleButton.addEventListener("click", () => {
      soundEnabled = !soundEnabled;
      updateSoundToggle();
    });

    loadScores();
    updateGameState();
    updateSoundToggle();
    renderBoard();
    updateTurnIndicator();
  </script>
</body>
</html>
